/* automatically generated by rust-bindgen 0.60.1 */

pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 36;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
#[doc = " Event types"]
pub const projectMEvent_PROJECTM_KEYUP: projectMEvent = 0;
#[doc = " Event types"]
pub const projectMEvent_PROJECTM_KEYDOWN: projectMEvent = 1;
#[doc = " Event types"]
pub const projectMEvent_PROJECTM_VIDEORESIZE: projectMEvent = 2;
#[doc = " Event types"]
pub const projectMEvent_PROJECTM_VIDEOQUIT: projectMEvent = 3;
pub type projectMEvent = ::std::os::raw::c_uint;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_RETURN: projectMKeycode = 0;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_RIGHT: projectMKeycode = 1;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_LEFT: projectMKeycode = 2;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_UP: projectMKeycode = 3;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_DOWN: projectMKeycode = 4;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_PAGEUP: projectMKeycode = 5;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_PAGEDOWN: projectMKeycode = 6;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_INSERT: projectMKeycode = 7;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_DELETE: projectMKeycode = 8;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_ESCAPE: projectMKeycode = 9;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_LSHIFT: projectMKeycode = 10;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_RSHIFT: projectMKeycode = 11;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_CAPSLOCK: projectMKeycode = 12;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_LCTRL: projectMKeycode = 13;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_HOME: projectMKeycode = 14;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_END: projectMKeycode = 15;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_BACKSPACE: projectMKeycode = 16;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_SLASH: projectMKeycode = 17;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_BACKSLASH: projectMKeycode = 18;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_F1: projectMKeycode = 19;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_F2: projectMKeycode = 20;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_F3: projectMKeycode = 21;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_F4: projectMKeycode = 22;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_F5: projectMKeycode = 23;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_F6: projectMKeycode = 24;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_F7: projectMKeycode = 25;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_F8: projectMKeycode = 26;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_F9: projectMKeycode = 27;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_F10: projectMKeycode = 28;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_F11: projectMKeycode = 29;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_F12: projectMKeycode = 30;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_0: projectMKeycode = 48;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_1: projectMKeycode = 49;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_2: projectMKeycode = 50;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_3: projectMKeycode = 51;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_4: projectMKeycode = 52;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_5: projectMKeycode = 53;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_6: projectMKeycode = 54;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_7: projectMKeycode = 55;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_8: projectMKeycode = 56;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_9: projectMKeycode = 57;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_A: projectMKeycode = 65;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_B: projectMKeycode = 66;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_C: projectMKeycode = 67;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_D: projectMKeycode = 68;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_E: projectMKeycode = 69;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_F: projectMKeycode = 70;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_G: projectMKeycode = 71;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_H: projectMKeycode = 72;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_I: projectMKeycode = 73;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_J: projectMKeycode = 74;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_K: projectMKeycode = 75;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_L: projectMKeycode = 76;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_M: projectMKeycode = 77;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_N: projectMKeycode = 78;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_O: projectMKeycode = 79;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_P: projectMKeycode = 80;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_Q: projectMKeycode = 81;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_R: projectMKeycode = 82;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_S: projectMKeycode = 83;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_T: projectMKeycode = 84;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_U: projectMKeycode = 85;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_V: projectMKeycode = 86;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_W: projectMKeycode = 87;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_X: projectMKeycode = 88;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_Y: projectMKeycode = 89;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_Z: projectMKeycode = 90;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_a: projectMKeycode = 97;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_b: projectMKeycode = 98;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_c: projectMKeycode = 99;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_d: projectMKeycode = 100;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_e: projectMKeycode = 101;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_f: projectMKeycode = 102;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_g: projectMKeycode = 103;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_h: projectMKeycode = 104;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_i: projectMKeycode = 105;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_j: projectMKeycode = 106;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_k: projectMKeycode = 107;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_l: projectMKeycode = 108;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_m: projectMKeycode = 109;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_n: projectMKeycode = 110;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_o: projectMKeycode = 111;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_p: projectMKeycode = 112;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_q: projectMKeycode = 113;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_r: projectMKeycode = 114;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_s: projectMKeycode = 115;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_t: projectMKeycode = 116;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_u: projectMKeycode = 117;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_v: projectMKeycode = 118;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_w: projectMKeycode = 119;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_x: projectMKeycode = 120;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_y: projectMKeycode = 121;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_z: projectMKeycode = 122;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_NONE: projectMKeycode = 123;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_PLUS: projectMKeycode = 124;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_MINUS: projectMKeycode = 125;
#[doc = " Keycodes"]
pub const projectMKeycode_PROJECTM_K_EQUALS: projectMKeycode = 126;
pub type projectMKeycode = ::std::os::raw::c_uint;
#[doc = " Modifiers"]
pub const projectMModifier_PROJECTM_KMOD_NONE: projectMModifier = -1;
#[doc = " Modifiers"]
pub const projectMModifier_PROJECTM_KMOD_LSHIFT: projectMModifier = 0;
#[doc = " Modifiers"]
pub const projectMModifier_PROJECTM_KMOD_RSHIFT: projectMModifier = 1;
#[doc = " Modifiers"]
pub const projectMModifier_PROJECTM_KMOD_CAPS: projectMModifier = 2;
#[doc = " Modifiers"]
pub const projectMModifier_PROJECTM_KMOD_LCTRL: projectMModifier = 3;
#[doc = " Modifiers"]
pub const projectMModifier_PROJECTM_KMOD_RCTRL: projectMModifier = 4;
pub type projectMModifier = ::std::os::raw::c_int;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    fn test_field___clang_max_align_nonce1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<max_align_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(max_align_t),
                "::",
                stringify!(__clang_max_align_nonce1)
            )
        );
    }
    test_field___clang_max_align_nonce1();
    fn test_field___clang_max_align_nonce2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<max_align_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(max_align_t),
                "::",
                stringify!(__clang_max_align_nonce2)
            )
        );
    }
    test_field___clang_max_align_nonce2();
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__fsid_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__fsid_t),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct projectm {
    _unused: [u8; 0],
}
pub type projectm_handle = *mut projectm;
#[doc = " @brief projectM instance settings."]
#[doc = ""]
#[doc = " <p>Use this struct to provide settings for projectM, for example if your application handles projectM configuration"]
#[doc = " internally instead of using the default configuration file.</p>"]
#[doc = ""]
#[doc = " <p>Always allocate the struct using the projectm_alloc_settings() and free it with the projectm_free_settings()"]
#[doc = " function.</p>"]
#[doc = ""]
#[doc = " <p>To allocate memory for char* members, always use projectm_alloc_string(). If any pointer is not NULL,"]
#[doc = " projectm_free_settings() will automatically call projectm_free_string() on it. If you free it on your own, remember"]
#[doc = " to reset the pointer to NULL after doing so!</p>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct projectm_settings_s {
    #[doc = "!< Per-pixel mesh X resolution."]
    pub mesh_x: ::std::os::raw::c_int,
    #[doc = "!< Per-pixel mesh Y resolution."]
    pub mesh_y: ::std::os::raw::c_int,
    #[doc = "!< Target rendering frames per second."]
    pub fps: ::std::os::raw::c_int,
    #[doc = "!< Size of the render texture. Must be a power of 2."]
    pub texture_size: ::std::os::raw::c_int,
    #[doc = "!< Width of the rendering viewport."]
    pub window_width: ::std::os::raw::c_int,
    #[doc = "!< Height of the rendering viewport."]
    pub window_height: ::std::os::raw::c_int,
    #[doc = "!< Path with preset files to be loaded into the playlist. Use FLAG_DISABLE_PLAYLIST_LOAD to skip automatic loading of presets."]
    pub preset_path: *mut ::std::os::raw::c_char,
    #[doc = "!< Additional path with texture files for use in presets."]
    pub texture_path: *mut ::std::os::raw::c_char,
    #[doc = "!< Path to data files like default textures and presets."]
    pub data_path: *mut ::std::os::raw::c_char,
    #[doc = "!< Display duration for each preset in seconds."]
    pub preset_duration: f64,
    #[doc = "!< Blend-over duration between two presets in seconds."]
    pub soft_cut_duration: f64,
    #[doc = "!< Minimum time in seconds a preset is displayed before a hard cut can happen."]
    pub hard_cut_duration: f64,
    #[doc = "!< Set to true to enable fast beat-driven preset switches."]
    pub hard_cut_enabled: bool,
    #[doc = "!< Beat sensitivity value that must be surpassed for a hard cut."]
    pub hard_cut_sensitivity: f32,
    #[doc = "!< Beat sensitivity. Standard sensitivity is 1.0."]
    pub beat_sensitivity: f32,
    #[doc = "!< Use aspect ration correction in presets that support it."]
    pub aspect_correction: bool,
    #[doc = "!< Used as the \"sigma\" value for a gaussian RNG to randomize preset duration. Unused on Windows."]
    pub easter_egg: f32,
    #[doc = "!< Enable playlist shuffle, selecting a random preset on each switch instead of the next in list."]
    pub shuffle_enabled: bool,
    #[doc = "!< If true, use soft cut ratings on soft cuts and hard cut ratings on hard cuts. If false, the hard cut rating is always used."]
    pub soft_cut_ratings_enabled: bool,
}
#[test]
fn bindgen_test_layout_projectm_settings_s() {
    assert_eq!(
        ::std::mem::size_of::<projectm_settings_s>(),
        96usize,
        concat!("Size of: ", stringify!(projectm_settings_s))
    );
    assert_eq!(
        ::std::mem::align_of::<projectm_settings_s>(),
        8usize,
        concat!("Alignment of ", stringify!(projectm_settings_s))
    );
    fn test_field_mesh_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<projectm_settings_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mesh_x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(projectm_settings_s),
                "::",
                stringify!(mesh_x)
            )
        );
    }
    test_field_mesh_x();
    fn test_field_mesh_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<projectm_settings_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mesh_y) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(projectm_settings_s),
                "::",
                stringify!(mesh_y)
            )
        );
    }
    test_field_mesh_y();
    fn test_field_fps() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<projectm_settings_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fps) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(projectm_settings_s),
                "::",
                stringify!(fps)
            )
        );
    }
    test_field_fps();
    fn test_field_texture_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<projectm_settings_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).texture_size) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(projectm_settings_s),
                "::",
                stringify!(texture_size)
            )
        );
    }
    test_field_texture_size();
    fn test_field_window_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<projectm_settings_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).window_width) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(projectm_settings_s),
                "::",
                stringify!(window_width)
            )
        );
    }
    test_field_window_width();
    fn test_field_window_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<projectm_settings_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).window_height) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(projectm_settings_s),
                "::",
                stringify!(window_height)
            )
        );
    }
    test_field_window_height();
    fn test_field_preset_path() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<projectm_settings_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).preset_path) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(projectm_settings_s),
                "::",
                stringify!(preset_path)
            )
        );
    }
    test_field_preset_path();
    fn test_field_texture_path() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<projectm_settings_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).texture_path) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(projectm_settings_s),
                "::",
                stringify!(texture_path)
            )
        );
    }
    test_field_texture_path();
    fn test_field_data_path() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<projectm_settings_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data_path) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(projectm_settings_s),
                "::",
                stringify!(data_path)
            )
        );
    }
    test_field_data_path();
    fn test_field_preset_duration() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<projectm_settings_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).preset_duration) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(projectm_settings_s),
                "::",
                stringify!(preset_duration)
            )
        );
    }
    test_field_preset_duration();
    fn test_field_soft_cut_duration() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<projectm_settings_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).soft_cut_duration) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(projectm_settings_s),
                "::",
                stringify!(soft_cut_duration)
            )
        );
    }
    test_field_soft_cut_duration();
    fn test_field_hard_cut_duration() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<projectm_settings_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hard_cut_duration) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(projectm_settings_s),
                "::",
                stringify!(hard_cut_duration)
            )
        );
    }
    test_field_hard_cut_duration();
    fn test_field_hard_cut_enabled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<projectm_settings_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hard_cut_enabled) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(projectm_settings_s),
                "::",
                stringify!(hard_cut_enabled)
            )
        );
    }
    test_field_hard_cut_enabled();
    fn test_field_hard_cut_sensitivity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<projectm_settings_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hard_cut_sensitivity) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(projectm_settings_s),
                "::",
                stringify!(hard_cut_sensitivity)
            )
        );
    }
    test_field_hard_cut_sensitivity();
    fn test_field_beat_sensitivity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<projectm_settings_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).beat_sensitivity) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(projectm_settings_s),
                "::",
                stringify!(beat_sensitivity)
            )
        );
    }
    test_field_beat_sensitivity();
    fn test_field_aspect_correction() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<projectm_settings_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).aspect_correction) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(projectm_settings_s),
                "::",
                stringify!(aspect_correction)
            )
        );
    }
    test_field_aspect_correction();
    fn test_field_easter_egg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<projectm_settings_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).easter_egg) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(projectm_settings_s),
                "::",
                stringify!(easter_egg)
            )
        );
    }
    test_field_easter_egg();
    fn test_field_shuffle_enabled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<projectm_settings_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shuffle_enabled) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(projectm_settings_s),
                "::",
                stringify!(shuffle_enabled)
            )
        );
    }
    test_field_shuffle_enabled();
    fn test_field_soft_cut_ratings_enabled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<projectm_settings_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).soft_cut_ratings_enabled) as usize - ptr as usize
            },
            93usize,
            concat!(
                "Offset of field: ",
                stringify!(projectm_settings_s),
                "::",
                stringify!(soft_cut_ratings_enabled)
            )
        );
    }
    test_field_soft_cut_ratings_enabled();
}
#[doc = " @brief projectM instance settings."]
#[doc = ""]
#[doc = " <p>Use this struct to provide settings for projectM, for example if your application handles projectM configuration"]
#[doc = " internally instead of using the default configuration file.</p>"]
#[doc = ""]
#[doc = " <p>Always allocate the struct using the projectm_alloc_settings() and free it with the projectm_free_settings()"]
#[doc = " function.</p>"]
#[doc = ""]
#[doc = " <p>To allocate memory for char* members, always use projectm_alloc_string(). If any pointer is not NULL,"]
#[doc = " projectm_free_settings() will automatically call projectm_free_string() on it. If you free it on your own, remember"]
#[doc = " to reset the pointer to NULL after doing so!</p>"]
pub type projectm_settings = projectm_settings_s;
#[doc = "!< No flags."]
pub const projectm_flags_PROJECTM_FLAG_NONE: projectm_flags = 0;
#[doc = "!< Set this flag to disable loading a preset playlist on startup."]
pub const projectm_flags_PROJECTM_FLAG_DISABLE_PLAYLIST_LOAD: projectm_flags = 1;
#[doc = " Flags that influence projectM instance creation."]
pub type projectm_flags = ::std::os::raw::c_uint;
pub const projectm_channels_PROJECTM_MONO: projectm_channels = 1;
pub const projectm_channels_PROJECTM_STEREO: projectm_channels = 2;
#[doc = " For specifying audio data format."]
pub type projectm_channels = ::std::os::raw::c_uint;
#[doc = "!< Rating for hard cuts."]
pub const projectm_preset_rating_type_PROJECTM_HARD_CUT_RATING_TYPE: projectm_preset_rating_type =
    0;
#[doc = "!< Rating for soft cuts."]
pub const projectm_preset_rating_type_PROJECTM_SOFT_CUT_RATING_TYPE: projectm_preset_rating_type =
    1;
#[doc = " Rating types supported by projectM. Used to control preset selection for different types"]
#[doc = " of transitions (hard/soft)."]
pub type projectm_preset_rating_type = ::std::os::raw::c_uint;
#[doc = "!< Left audio channel."]
pub const projectm_pcm_channel_PROJECTM_CHANNEL_L: projectm_pcm_channel = 0;
#[doc = "!< Left audio channel."]
pub const projectm_pcm_channel_PROJECTM_CHANNEL_0: projectm_pcm_channel = 0;
#[doc = "!< Right audio channel."]
pub const projectm_pcm_channel_PROJECTM_CHANNEL_R: projectm_pcm_channel = 1;
#[doc = "!< Right audio channel."]
pub const projectm_pcm_channel_PROJECTM_CHANNEL_1: projectm_pcm_channel = 1;
#[doc = " Placeholder values that can be used to address channel indices in PCM data arrays."]
pub type projectm_pcm_channel = ::std::os::raw::c_uint;
#[doc = "!< Random waveform type."]
pub const projectm_touch_type_PROJECTM_TOUCH_TYPE_RANDOM: projectm_touch_type = 0;
#[doc = "!< Draws a circular waveform."]
pub const projectm_touch_type_PROJECTM_TOUCH_TYPE_CIRCLE: projectm_touch_type = 1;
#[doc = "!< Draws a radial blob waveform."]
pub const projectm_touch_type_PROJECTM_TOUCH_TYPE_RADIAL_BLOB: projectm_touch_type = 2;
#[doc = "!< Draws a blob-style waveform."]
pub const projectm_touch_type_PROJECTM_TOUCH_TYPE_BLOB2: projectm_touch_type = 3;
#[doc = "!< Draws another blob-style waveform."]
pub const projectm_touch_type_PROJECTM_TOUCH_TYPE_BLOB3: projectm_touch_type = 4;
#[doc = "!< Draws a derivative-line waveform."]
pub const projectm_touch_type_PROJECTM_TOUCH_TYPE_DERIVATIVE_LINE: projectm_touch_type = 5;
#[doc = "!< Draws a five-blob waveform."]
pub const projectm_touch_type_PROJECTM_TOUCH_TYPE_BLOB5: projectm_touch_type = 6;
#[doc = "!< Draws a single-line waveform."]
pub const projectm_touch_type_PROJECTM_TOUCH_TYPE_LINE: projectm_touch_type = 7;
#[doc = "!< Draws a double-line waveform."]
pub const projectm_touch_type_PROJECTM_TOUCH_TYPE_DOUBLE_LINE: projectm_touch_type = 8;
#[doc = " Waveform render types used in the touch start method."]
pub type projectm_touch_type = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Allocates memory for a string and returns the pointer."]
    #[doc = ""]
    #[doc = " To free the allocated memory, call projectm_free_string(). Do not use free()!"]
    #[doc = ""]
    #[doc = " @return A pointer to a zero-initialized memory area."]
    pub fn projectm_alloc_string(length: ::std::os::raw::c_uint) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Frees the memory of an allocated string."]
    #[doc = ""]
    #[doc = " <p>Frees the memory allocated by a call to projectm_alloc_string() or any"]
    #[doc = " (const) char* pointers returned by a projectM API call.</p>"]
    #[doc = ""]
    #[doc = " <p>Do not use free() to delete the pointer!</p>"]
    #[doc = ""]
    #[doc = " @param settings A pointer returned by projectm_alloc_string()."]
    pub fn projectm_free_string(str_: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " @brief Allocates memory for a projectm_settings struct and returns the pointer."]
    #[doc = ""]
    #[doc = " <p>This will not allocate memory for the char* members in the struct. These will be set to NULL initially."]
    #[doc = " To store a string in these members, use projectm_alloc_string() to allocate the required memory. Do not use"]
    #[doc = " malloc()!</p>"]
    #[doc = ""]
    #[doc = " <p>To free the allocated memory, call projectm_free_settings(). Do not use free()!</p>"]
    #[doc = ""]
    #[doc = " @return A pointer to a zero-initialized projectm_settings struct."]
    pub fn projectm_alloc_settings() -> *mut projectm_settings;
}
extern "C" {
    #[doc = " @brief Frees the memory of an allocated projectm_settings structure."]
    #[doc = ""]
    #[doc = " <p>Frees the memory allocated by a call to projectm_alloc_settings() or any"]
    #[doc = " projectm_settings pointer returned by an API call. Any non-null char pointers"]
    #[doc = " will also be free'd using projectm_free_string().</p>"]
    #[doc = ""]
    #[doc = " <p>Do not use free() to delete the pointer!</p>"]
    #[doc = ""]
    #[doc = " @param settings A pointer returned by projectm_alloc_settings()."]
    pub fn projectm_free_settings(settings: *const projectm_settings);
}
#[doc = " @brief Callback function that is executed on each preset change."]
#[doc = ""]
#[doc = " Can be used for example to update the application window title."]
#[doc = ""]
#[doc = " @param is_hard_cut True if the preset was switched using a hard cut via beat detection."]
#[doc = " @param index The playlist index of the new preset."]
#[doc = " @param user_data A user-defined data pointer that was provided when registering the callback,"]
#[doc = "                  e.g. context information."]
pub type projectm_preset_switched_event = ::std::option::Option<
    unsafe extern "C" fn(
        is_hard_cut: bool,
        index: ::std::os::raw::c_uint,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @brief Callback function that is executed is the shuffle setting has changed."]
#[doc = " @param shuffle_enabled True if shuffle is enabled, false if it was disabled."]
#[doc = " @param user_data A user-defined data pointer that was provided when registering the callback,"]
#[doc = "                  e.g. context information."]
pub type projectm_shuffle_enable_changed_event = ::std::option::Option<
    unsafe extern "C" fn(shuffle_enabled: bool, user_data: *mut ::std::os::raw::c_void),
>;
#[doc = " @brief Callback function that is executed if a preset change failed."]
#[doc = ""]
#[doc = " The message pointer is only valid inside the callback. Make a copy if it must be kept"]
#[doc = " for later use."]
#[doc = ""]
#[doc = " @param is_hard_cut True if the preset was switched using a hard cut via beat detection."]
#[doc = " @param index The playlist index of the new preset."]
#[doc = " @param message The error message."]
#[doc = " @param user_data A user-defined data pointer that was provided when registering the callback,"]
#[doc = "                  e.g. context information."]
pub type projectm_preset_switch_failed_event = ::std::option::Option<
    unsafe extern "C" fn(
        is_hard_cut: bool,
        index: ::std::os::raw::c_uint,
        message: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @brief Callback function that is executed if a preset rating has been changed."]
#[doc = ""]
#[doc = " Can be used for example to update the rating display in the host application."]
#[doc = ""]
#[doc = " @param index The playlist index of the new preset."]
#[doc = " @param rating The new rating value."]
#[doc = " @param rating_type The rating type that has been changed."]
#[doc = " @param user_data A user-defined data pointer that was provided when registering the callback,"]
#[doc = "                  e.g. context information."]
pub type projectm_preset_rating_changed_event = ::std::option::Option<
    unsafe extern "C" fn(
        index: ::std::os::raw::c_uint,
        rating: ::std::os::raw::c_int,
        rating_type: projectm_preset_rating_type,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " @brief Creates a new projectM instance, reading settings from the given file."]
    #[doc = " @param setting_file_path A path to the settings file to read the configuration from."]
    #[doc = "                          If NULL or an empty path are provided, default settings will be used."]
    #[doc = " @param flags Any combination of values from the projectm_flags enumeration."]
    #[doc = " @return A projectM handle for the newly created instance that must be used in subsequent API calls."]
    #[doc = "         NULL if the instance could not be created successfully."]
    pub fn projectm_create(
        setting_file_path: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> projectm_handle;
}
extern "C" {
    #[doc = " @brief Creates a new projectM instance with given settings."]
    #[doc = " @param settings A pointer to a projectm_settings_t with the settings to be used by the new instance."]
    #[doc = "                 If this pointer is NULL, default settings will be used."]
    #[doc = " @param flags Any combination of values from the projectm_flags enumeration."]
    #[doc = " @return A projectM handle for the newly created instance that must be used in subsequent API calls."]
    #[doc = "         NULL if the instance could not be created successfully."]
    pub fn projectm_create_settings(
        settings: *const projectm_settings,
        flags: ::std::os::raw::c_int,
    ) -> projectm_handle;
}
extern "C" {
    #[doc = " @brief Destroys the given instance and frees the resources."]
    #[doc = ""]
    #[doc = " After destroying the handle, it must not be used for any other calls to the API."]
    #[doc = ""]
    #[doc = " @param instance A handle returned by projectm_create() or projectm_create_settings()."]
    pub fn projectm_destroy(instance: projectm_handle);
}
extern "C" {
    #[doc = " @brief Sets a callback function that will be called when a preset changes."]
    #[doc = ""]
    #[doc = " Only one callback can be registered per projectM instance. To remove the callback, use NULL."]
    #[doc = ""]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param callback A pointer to the callback function."]
    #[doc = " @param user_data A pointer to any data that will be sent back in the callback, e.g. context information."]
    pub fn projectm_set_preset_switched_event_callback(
        instance: projectm_handle,
        callback: projectm_preset_switched_event,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @brief Sets a callback function that will be called when the shuffle setting changes."]
    #[doc = ""]
    #[doc = " Only one callback can be registered per projectM instance. To remove the callback, use NULL."]
    #[doc = ""]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param callback A pointer to the callback function."]
    #[doc = " @param user_data A pointer to any data that will be sent back in the callback, e.g. context information."]
    pub fn projectm_set_shuffle_enable_changed_event_callback(
        instance: projectm_handle,
        callback: projectm_shuffle_enable_changed_event,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @brief Sets a callback function that will be called when a preset change failed."]
    #[doc = ""]
    #[doc = " Only one callback can be registered per projectM instance. To remove the callback, use NULL."]
    #[doc = ""]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param callback A pointer to the callback function."]
    #[doc = " @param user_data A pointer to any data that will be sent back in the callback, e.g. context information."]
    pub fn projectm_set_preset_switch_failed_event_callback(
        instance: projectm_handle,
        callback: projectm_preset_switch_failed_event,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @brief Sets a callback function that will be called when a preset rating changed."]
    #[doc = ""]
    #[doc = " Only one callback can be registered per projectM instance. To remove the callback, use NULL."]
    #[doc = ""]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param callback A pointer to the callback function."]
    #[doc = " @param user_data A pointer to any data that will be sent back in the callback, e.g. context information."]
    pub fn projectm_set_preset_rating_changed_event_callback(
        instance: projectm_handle,
        callback: projectm_preset_rating_changed_event,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @brief Reloads all textures."]
    #[doc = ""]
    #[doc = " Also resets the OpenGL renderer without changing the viewport size. Useful if preset paths were changed."]
    #[doc = ""]
    #[doc = " @param instance The projectM instance handle."]
    pub fn projectm_reset_textures(instance: projectm_handle);
}
extern "C" {
    #[doc = " @brief Renders a single frame."]
    #[doc = ""]
    #[doc = " @note Separate two-pass frame rendering is currently not supported by the C API as it is rarely used"]
    #[doc = "       and also depends on the loaded preset."]
    #[doc = ""]
    #[doc = " @param instance The projectM instance handle."]
    pub fn projectm_render_frame(instance: projectm_handle);
}
extern "C" {
    #[doc = " @brief Enables render-to-texture."]
    #[doc = ""]
    #[doc = " Useful if projectM output will be part of a more complex OpenGL scene. The size of the texture is determined by the"]
    #[doc = " given viewport size and the dimensions should be a power of 2."]
    #[doc = ""]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @return A GLuint value with the texture ID projectM will render to."]
    pub fn projectm_init_render_to_texture(instance: projectm_handle) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @brief Key handler that processes user input."]
    #[doc = ""]
    #[doc = " <p>This method can be used to send user input in the host application to projectM, for example"]
    #[doc = " to switch presets, display the help and search menus or change settings like beat sensitivity.</p>"]
    #[doc = ""]
    #[doc = " <p>All actions executed by the key handler can also be run programmatically if the host application"]
    #[doc = " is not able to redirect keyboard input to projectM.</p>"]
    #[doc = ""]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param event The key event, valid are either PROJECTM_KEYUP or PROJECTM_KEYDOWN."]
    #[doc = " @param keycode The key code, mapped to a value of the projectMKeycode enumeration."]
    #[doc = " @param modifier The key modifier as a value from the projectMModifier."]
    pub fn projectm_key_handler(
        instance: projectm_handle,
        event: projectMEvent,
        keycode: projectMKeycode,
        modifier: projectMModifier,
    );
}
extern "C" {
    #[doc = " @brief Default key handler that processes user input."]
    #[doc = ""]
    #[doc = " <p>This method can be used to send user input in the host application to projectM, for example"]
    #[doc = " to switch presets, display the help and search menus or change settings like beat sensitivity.</p>"]
    #[doc = ""]
    #[doc = " <p>All actions executed by the key handler can also be run programmatically if the host application"]
    #[doc = " is not able to redirect keyboard input to projectM.</p>"]
    #[doc = ""]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param event The key event, valid are either PROJECTM_KEYUP or PROJECTM_KEYDOWN."]
    #[doc = " @param keycode The key code, mapped to a value of the projectMKeycode enumeration."]
    pub fn projectm_default_key_handler(
        instance: projectm_handle,
        event: projectMEvent,
        keycode: projectMKeycode,
    );
}
extern "C" {
    #[doc = " @brief Returns the size of the internal render texture."]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @return The size of the internal rendering texture."]
    pub fn projectm_get_texture_size(instance: projectm_handle) -> size_t;
}
extern "C" {
    #[doc = " @brief Changes the size of the internal render texture."]
    #[doc = " @note This will recreate the internal renderer."]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param size The new size of the render texture. Must be a power of 2."]
    pub fn projectm_set_texture_size(instance: projectm_handle, size: size_t);
}
extern "C" {
    #[doc = " @brief Sets the beat sensitivity."]
    #[doc = ""]
    #[doc = " The beat sensitivity to be used."]
    #[doc = ""]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param sensitivity The sensitivity setting."]
    pub fn projectm_set_beat_sensitivity(instance: projectm_handle, sensitivity: f32);
}
extern "C" {
    #[doc = " @brief Returns the beat sensitivity."]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @return The current sensitivity setting."]
    pub fn projectm_get_beat_sensitivity(instance: projectm_handle) -> f32;
}
extern "C" {
    #[doc = " @brief Returns the minimum display time before a hard cut can happen."]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @return The minimum number of seconds the preset will be displayed before a hard cut."]
    pub fn projectm_get_hard_cut_duration(instance: projectm_handle) -> f64;
}
extern "C" {
    #[doc = " @brief Sets the minimum display time before a hard cut can happen."]
    #[doc = ""]
    #[doc = " <p>Hard cuts are beat-sensitive preset transitions, immediately changing from"]
    #[doc = " one preset to the next without a smooth blending period.</p>"]
    #[doc = ""]
    #[doc = " <p>Set this to a higher value than preset duration to disable hard cuts.</p>"]
    #[doc = ""]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param seconds Minimum number of seconds the preset will be displayed before a hard cut."]
    pub fn projectm_set_hard_cut_duration(instance: projectm_handle, seconds: f64);
}
extern "C" {
    #[doc = " @brief Returns whether hard cuts are enabled or not."]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @return True if hard cuts are enabled, false otherwise."]
    pub fn projectm_get_hard_cut_enabled(instance: projectm_handle) -> bool;
}
extern "C" {
    #[doc = " @brief Enables or disables hard cuts."]
    #[doc = ""]
    #[doc = " Even if enabled, the hard cut duration must be set to a value lower than the preset duration"]
    #[doc = " to work properly."]
    #[doc = ""]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param enabled True to enable hard cuts, false to disable."]
    pub fn projectm_set_hard_cut_enabled(instance: projectm_handle, enabled: bool);
}
extern "C" {
    #[doc = " @brief Returns the current hard cut sensitivity."]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @return The current hard cut sensitivity."]
    pub fn projectm_get_hard_cut_sensitivity(instance: projectm_handle) -> f32;
}
extern "C" {
    #[doc = " @brief Sets the hard cut volume sensitivity."]
    #[doc = ""]
    #[doc = " The beat detection volume difference that must be surpassed to trigger a hard cut."]
    #[doc = ""]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param sensitivity The volume threshold that triggers a hard cut if surpassed."]
    pub fn projectm_set_hard_cut_sensitivity(instance: projectm_handle, sensitivity: f32);
}
extern "C" {
    #[doc = " @brief Returns the time in seconds for a soft transition between two presets."]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @return Time in seconds it takes to smoothly transition from one preset to another."]
    pub fn projectm_get_soft_cut_duration(instance: projectm_handle) -> f64;
}
extern "C" {
    #[doc = " @brief Sets the time in seconds for a soft transition between two presets."]
    #[doc = ""]
    #[doc = " During a soft cut, both presets are rendered and slowly transitioned from one"]
    #[doc = " to the other."]
    #[doc = ""]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param seconds Time in seconds it takes to smoothly transition from one preset to another."]
    pub fn projectm_set_soft_cut_duration(instance: projectm_handle, seconds: f64);
}
extern "C" {
    #[doc = " @brief Sets the preset display duration before switching to the next using a soft cut."]
    #[doc = ""]
    #[doc = " This can be considered as the maximum time a preset is displayed. If this time is reached,"]
    #[doc = " a smooth cut will be initiated. A hard cut, if any, will always happen before this time."]
    #[doc = ""]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param seconds The number of seconds a preset will be displayed before the next is shown."]
    pub fn projectm_set_preset_duration(instance: projectm_handle, seconds: f64);
}
extern "C" {
    #[doc = " @brief Returns the per-pixel equation mesh size in units."]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param width The width of the mesh."]
    #[doc = " @param height The height of the mesh."]
    pub fn projectm_get_mesh_size(
        instance: projectm_handle,
        width: *mut size_t,
        height: *mut size_t,
    );
}
extern "C" {
    #[doc = " @brief Sets the per-pixel equation mesh size in units."]
    #[doc = " @note This will recreate the renderer."]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param width The new width of the mesh."]
    #[doc = " @param height The new height of the mesh."]
    pub fn projectm_set_mesh_size(instance: projectm_handle, width: size_t, height: size_t);
}
extern "C" {
    #[doc = " @brief Returns the target frames per second count."]
    #[doc = " @note This is not the actual FPS, but the targeted refresh framerate if the integrating application."]
    #[doc = " @param instance The projectM instance handle."]
    pub fn projectm_get_fps(instance: projectm_handle) -> size_t;
}
extern "C" {
    #[doc = " @brief Returns the search path for presets and textures."]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @return The path used to search for presets and textures."]
    pub fn projectm_get_preset_path(instance: projectm_handle) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Returns the search path for additional textures."]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @return The path used to search for additional textures."]
    pub fn projectm_get_texture_path(instance: projectm_handle) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Returns the path projectM uses to search for additional data."]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @return The data dir path."]
    pub fn projectm_get_data_path(instance: projectm_handle) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Enabled or disables aspect ratio correction in presets that support it."]
    #[doc = ""]
    #[doc = " This sets a flag presets can use to aspect-correct rendered shapes, which otherwise would"]
    #[doc = " be distorted if the viewport isn't exactly square."]
    #[doc = ""]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param enabled True to enable aspect correction, false to disable it."]
    pub fn projectm_set_aspect_correction(instance: projectm_handle, enabled: bool);
}
extern "C" {
    #[doc = " @brief Returns whether aspect ratio correction is enabled or not."]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @return True if aspect ratio correction is enabled, false otherwise."]
    pub fn projectm_get_aspect_correction(instance: projectm_handle) -> bool;
}
extern "C" {
    #[doc = " @brief Sets the \"easter egg\" value."]
    #[doc = ""]
    #[doc = " <p>This doesn't enable any fancy feature, it only influences the randomized display time of presets. It's"]
    #[doc = " passed as the \"sigma\" value of the gaussian random number generator used to determine the maximum display time,"]
    #[doc = " effectively multiplying the generated number of seconds by this amount.</p>"]
    #[doc = ""]
    #[doc = " <p>See function sampledPresetDuration() of the TimeKeeper class on how it is used.</p>"]
    #[doc = ""]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param value The new \"easter egg\" value."]
    pub fn projectm_set_easter_egg(instance: projectm_handle, value: f32);
}
extern "C" {
    #[doc = " @brief Returns the current \"easter egg\" value."]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @return The current \"easter egg\" value."]
    pub fn projectm_get_easter_egg(instance: projectm_handle) -> f32;
}
extern "C" {
    #[doc = " @brief Starts a touch event or moves an existing waveform."]
    #[doc = ""]
    #[doc = " This will add or move waveforms in addition to the preset waveforms. If there is an existing waveform"]
    #[doc = " at the given coordinates, it will be centered on the new coordinates. If there is no waveform, a new one"]
    #[doc = " will be added."]
    #[doc = ""]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param x The x coordinate of the touch event."]
    #[doc = " @param y The y coordinate of the touch event."]
    #[doc = " @param pressure  The amount of pressure applied in a range from 0.0 to 1.0."]
    #[doc = " @param touch_type The waveform type that will be rendered on touch."]
    pub fn projectm_touch(
        instance: projectm_handle,
        x: f32,
        y: f32,
        pressure: ::std::os::raw::c_int,
        touch_type: projectm_touch_type,
    );
}
extern "C" {
    #[doc = " @brief Centers any waveforms under the coordinates to simulate dragging."]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param x The x coordinate of the drag."]
    #[doc = " @param y the y coordinate of the drag."]
    #[doc = " @param pressure The amount of pressure applied in a range from 0.0 to 1.0."]
    pub fn projectm_touch_drag(
        instance: projectm_handle,
        x: f32,
        y: f32,
        pressure: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Removes any additional touch waveforms under the given coordinates."]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param x The last known x touch coordinate."]
    #[doc = " @param y The last known y touch coordinate."]
    pub fn projectm_touch_destroy(instance: projectm_handle, x: f32, y: f32);
}
extern "C" {
    #[doc = " @brief Removes all touch waveforms from the screen."]
    #[doc = ""]
    #[doc = " Preset-defined waveforms will still be displayed."]
    #[doc = ""]
    #[doc = " @param instance The projectM instance handle."]
    pub fn projectm_touch_destroy_all(instance: projectm_handle);
}
extern "C" {
    #[doc = " @brief Returns a structure with the current projectM settings."]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @return A struct with all currently used settings."]
    pub fn projectm_get_settings(instance: projectm_handle) -> *mut projectm_settings;
}
extern "C" {
    #[doc = " @brief Saves the given settings struct into a file."]
    #[doc = ""]
    #[doc = " The file can be loaded during projectM initialization. This is useful if the application needs to"]
    #[doc = " keep settings separate from the global system/user configuration."]
    #[doc = ""]
    #[doc = " @param config_file The filename to store the settings in."]
    #[doc = " @param settings The settings struct to store."]
    pub fn projectm_write_config(
        config_file: *const ::std::os::raw::c_char,
        settings: *const projectm_settings,
    );
}
extern "C" {
    #[doc = " @brief Selects a preset, but does not display it."]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param index The preset index to select."]
    pub fn projectm_select_preset_position(
        instance: projectm_handle,
        index: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " @brief Selects and displays the preset."]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param index the preset to display."]
    #[doc = " @param hard_cut If true, a hard cut is made, otherwise it will be blended smoothly."]
    pub fn projectm_select_preset(
        instance: projectm_handle,
        index: ::std::os::raw::c_uint,
        hard_cut: bool,
    );
}
extern "C" {
    #[doc = " @brief Removes a preset from the playlist."]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param index The  preset index to remove from the playlist."]
    pub fn projectm_remove_preset(instance: projectm_handle, index: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " @brief Clears the preset playlist."]
    #[doc = " @param instance The projectM instance handle."]
    pub fn projectm_clear_playlist(instance: projectm_handle);
}
extern "C" {
    #[doc = " @brief Locks or unlocks the current preset."]
    #[doc = ""]
    #[doc = " Locking effectively disables automatic preset transitions, both hard and soft cuts. Programmatic"]
    #[doc = " preset switches will still be executed."]
    #[doc = ""]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param lock True to lock the current preset, false to enable automatic transitions."]
    pub fn projectm_lock_preset(instance: projectm_handle, lock: bool);
}
extern "C" {
    #[doc = " @brief Returns whether the current preset is locked or not."]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @return True if the preset lock is enabled, false otherwise."]
    pub fn projectm_is_preset_locked(instance: projectm_handle) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the playlist index for the given preset name."]
    #[doc = ""]
    #[doc = " If the preset name is found multiple times, the first matching index will be returned."]
    #[doc = ""]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param preset_name The preset name to search for."]
    #[doc = " @return The first found playlist index of the requested preset, or 0 if the preset wasn't found."]
    pub fn projectm_get_preset_index(
        instance: projectm_handle,
        preset_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @brief Displays the preset with the given name."]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param preset_name The preset name to search for."]
    #[doc = " @param hard_cut If true, the preset will be shown immediately, if false a soft transition will be rendered."]
    pub fn projectm_select_preset_by_name(
        instance: projectm_handle,
        preset_name: *const ::std::os::raw::c_char,
        hard_cut: bool,
    );
}
extern "C" {
    #[doc = " @brief Returns the currently selected preset index."]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param index A valid pointer to an unsigned int that will receive the preset index."]
    #[doc = " @return True if a preset idnex was returned, false if no preset was selected, e.g. the playlist is empty."]
    pub fn projectm_get_selected_preset_index(
        instance: projectm_handle,
        index: *mut ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Adds a new preset at the end of the playlist."]
    #[doc = ""]
    #[doc = " The rating list is one rating per value of the projectm_preset_rating_type enumeration, with each actual enum"]
    #[doc = " value used as the index. If the rating list has the wrong length, the preset will not be added."]
    #[doc = ""]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param preset_url The full path and filename of the preset."]
    #[doc = " @param preset_name The display name of the preset."]
    #[doc = " @param rating_list A list with ratings for the preset, one rating per rating type."]
    #[doc = " @param rating_list_length Length of the preset rating list."]
    pub fn projectm_add_preset_url(
        instance: projectm_handle,
        preset_url: *const ::std::os::raw::c_char,
        preset_name: *const ::std::os::raw::c_char,
        rating_list: *mut ::std::os::raw::c_int,
        rating_list_length: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " @brief Adds a new preset at the given position in the playlist."]
    #[doc = ""]
    #[doc = " The rating list is one rating per value of the projectm_preset_rating_type enumeration, with each actual enum"]
    #[doc = " value used as the index. If the rating list has the wrong length, the preset will not be added."]
    #[doc = ""]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param index The playlist index to insert the preset at. Must be less than or equal to the length of"]
    #[doc = "              the playlist."]
    #[doc = " @param preset_url The full path and filename of the preset."]
    #[doc = " @param preset_name The display name of the preset."]
    #[doc = " @param rating_list A list with ratings for the preset, one rating per rating type."]
    #[doc = " @param rating_list_length Length of the preset rating list."]
    pub fn projectm_insert_preset_url(
        instance: projectm_handle,
        index: ::std::os::raw::c_uint,
        preset_url: *const ::std::os::raw::c_char,
        preset_name: *const ::std::os::raw::c_char,
        rating_list: *mut ::std::os::raw::c_int,
        rating_list_length: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " @brief Returns whether the currently selected preset has a valid position in the playlist."]
    #[doc = ""]
    #[doc = " This function is useful to check if the currently displayed preset is still inside the bounds of"]
    #[doc = " the current playlist, for example after the playlist was changed."]
    #[doc = ""]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @return True if the position is valid, false if outside bounds."]
    pub fn projectm_preset_position_valid(instance: projectm_handle) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the path and filename of the preset at the requested playlist index."]
    #[doc = " @note Make sure the index is inside the playlist bounds!"]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param index The playlist index to return the filename for."]
    #[doc = " @return The full path and filename of the preset at the given index."]
    pub fn projectm_get_preset_filename(
        instance: projectm_handle,
        index: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Returns the display name of the preset at the requested playlist index."]
    #[doc = " @note Make sure the index is inside the playlist bounds!"]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param index The playlist index to return the display name for."]
    #[doc = " @return The display name of the preset at the given index."]
    pub fn projectm_get_preset_name(
        instance: projectm_handle,
        index: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Changes the display name of the given preset in the playlist."]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param index the playlist item index to change."]
    #[doc = " @param name The new display name."]
    pub fn projectm_set_preset_name(
        instance: projectm_handle,
        index: ::std::os::raw::c_uint,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Returns the rating for the given index and transition type."]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param index The playlist item to retrieve the rating from."]
    #[doc = " @param rating_type The rating type to retrieve, either hard or soft cut."]
    #[doc = " @return The rating value of the requested item and type."]
    pub fn projectm_get_preset_rating(
        instance: projectm_handle,
        index: ::std::os::raw::c_uint,
        rating_type: projectm_preset_rating_type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Changes the rating or a playlist item and type."]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param index the playlist item to change the rating of."]
    #[doc = " @param rating The new rating value."]
    #[doc = " @param rating_type The type of the rating, either hard or soft cut."]
    pub fn projectm_set_preset_rating(
        instance: projectm_handle,
        index: ::std::os::raw::c_uint,
        rating: ::std::os::raw::c_int,
        rating_type: projectm_preset_rating_type,
    );
}
extern "C" {
    #[doc = " @brief Returns the number of presets in the current playlist."]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @return The number of presets in the currently loaded playlist."]
    pub fn projectm_get_playlist_size(instance: projectm_handle) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @brief Returns whether playlist shuffling is currently enabled or not."]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @return True if shuffle is enabled, false if not."]
    pub fn projectm_get_shuffle_enabled(instance: projectm_handle) -> bool;
}
extern "C" {
    #[doc = " @brief Enables or disables preset playlist shuffling."]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param shuffle_enabled True to randomly select the next preset, false to skip to the next item in line."]
    pub fn projectm_set_shuffle_enabled(instance: projectm_handle, shuffle_enabled: bool);
}
extern "C" {
    #[doc = " @brief Gets the index of the provided preset name in the current search result list."]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param name The name of the preset to return the index for."]
    #[doc = " @return The search result list index of the given preset name."]
    pub fn projectm_get_search_index(
        instance: projectm_handle,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @brief Switches to the previous preset in the current playlist."]
    #[doc = ""]
    #[doc = " This is unaffected by the shuffle mode and will always switch to the previous item."]
    #[doc = ""]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param hard_cut True to immediately perform to the previous preset, false to do a soft transition."]
    pub fn projectm_select_previous_preset(instance: projectm_handle, hard_cut: bool);
}
extern "C" {
    #[doc = " @brief Switches to the next preset in the current playlist."]
    #[doc = ""]
    #[doc = " This is unaffected by the shuffle mode and will always switch to the next item."]
    #[doc = ""]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param hard_cut True to immediately perform to the next preset, false to do a soft transition."]
    pub fn projectm_select_next_preset(instance: projectm_handle, hard_cut: bool);
}
extern "C" {
    #[doc = " @brief Switches to a random preset in the current playlist."]
    #[doc = ""]
    #[doc = " This is unaffected by the shuffle mode and will always switch to a random item."]
    #[doc = ""]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param hard_cut True to immediately perform to a random preset, false to do a soft transition."]
    pub fn projectm_select_random_preset(instance: projectm_handle, hard_cut: bool);
}
extern "C" {
    #[doc = " @brief Returns the current viewport size in pixels."]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param width Valid pointer to a size_t variable that will receive the window width value."]
    #[doc = " @param height Valid pointer to a size_t variable that will receive the window height value."]
    pub fn projectm_get_window_size(
        instance: projectm_handle,
        width: *mut size_t,
        height: *mut size_t,
    );
}
extern "C" {
    #[doc = " @brief Sets the current viewport size in pixels."]
    #[doc = ""]
    #[doc = " Calling this function will reset the OpenGL renderer."]
    #[doc = ""]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param width New viewport width in pixels."]
    #[doc = " @param height New viewport height in pixels."]
    pub fn projectm_set_window_size(instance: projectm_handle, width: size_t, height: size_t);
}
extern "C" {
    #[doc = " @brief Returns whether the current preset was loaded successfully or not."]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @return True if the preset was not loaded successfully, false if it is displayed correctly."]
    pub fn projectm_get_error_loading_current_preset(instance: projectm_handle) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the maximum number of audio samples that can be stored."]
    #[doc = ""]
    #[doc = " Each PCM data update should not exceed this number of samples. If more samples"]
    #[doc = " are added, only this number of samples is stored and the remainder discarded."]
    #[doc = ""]
    #[doc = " @return The number of audio samples that are stored, per channel."]
    pub fn projectm_pcm_get_max_samples() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @brief Adds 32-bit floating-point audio samples."]
    #[doc = ""]
    #[doc = " This function is used to add new audio data to projectM's internal audio buffer. It is internally converted"]
    #[doc = " to 2-channel float data, duplicating the channel."]
    #[doc = ""]
    #[doc = " If stereo, the channel order in samples is LRLRLR."]
    #[doc = ""]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param samples An array of PCM samples."]
    #[doc = " Each sample is expected to be within the range -1 to 1."]
    #[doc = " @param count The number of audio samples in a channel."]
    #[doc = " @param channels If the buffer is mono or stereo."]
    #[doc = " Can be PROJECTM_MONO or PROJECTM_STEREO."]
    pub fn projectm_pcm_add_float(
        instance: projectm_handle,
        samples: *const f32,
        count: ::std::os::raw::c_uint,
        channels: projectm_channels,
    );
}
extern "C" {
    #[doc = " @brief Adds 16-bit integer audio samples."]
    #[doc = ""]
    #[doc = " This function is used to add new audio data to projectM's internal audio buffer. It is internally converted"]
    #[doc = " to 2-channel float data, duplicating the channel."]
    #[doc = ""]
    #[doc = " If stereo, the channel order in samples is LRLRLR."]
    #[doc = ""]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param samples An array of PCM samples."]
    #[doc = " @param count The number of audio samples in a channel."]
    #[doc = " @param channels If the buffer is mono or stereo."]
    #[doc = " Can be PROJECTM_MONO or PROJECTM_STEREO."]
    pub fn projectm_pcm_add_int16(
        instance: projectm_handle,
        samples: *const i16,
        count: ::std::os::raw::c_uint,
        channels: projectm_channels,
    );
}
extern "C" {
    #[doc = " @brief Adds 8-bit unsigned integer audio samples."]
    #[doc = ""]
    #[doc = " This function is used to add new audio data to projectM's internal audio buffer. It is internally converted"]
    #[doc = " to 2-channel float data, duplicating the channel."]
    #[doc = ""]
    #[doc = " If stereo, the channel order in samples is LRLRLR."]
    #[doc = ""]
    #[doc = " @param instance The projectM instance handle."]
    #[doc = " @param samples An array of PCM samples."]
    #[doc = " @param count The number of audio samples in a channel."]
    #[doc = " @param channels If the buffer is mono or stereo."]
    #[doc = " Can be PROJECTM_MONO or PROJECTM_STEREO."]
    pub fn projectm_pcm_add_uint8(
        instance: projectm_handle,
        samples: *const u8,
        count: ::std::os::raw::c_uint,
        channels: projectm_channels,
    );
}
extern "C" {
    #[doc = " @brief Writes a .bmp framedump after rendering the next main texture, before shaders are applied."]
    #[doc = ""]
    #[doc = " The image is written to the current working directory and is named \"frame_texture_contents-[date].bmp\"."]
    #[doc = ""]
    #[doc = " @param instance The projectM instance handle."]
    pub fn projectm_write_debug_image_on_next_frame(instance: projectm_handle);
}
